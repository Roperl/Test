#	1.1软件的概念

##	软件

###		什么是软件
	
	软件是在计算机系统支持下，能够完成特定功能和性能的程序、数据和相关的文档；
	
	软件=知识+数据+文档；

###		软件的特点
	
	软件是抽象的逻辑产品，而不是物理产品
	
### 	软件工程常用的8个质量要求的定义和解释

	正确性：软件满足需求规约即完成用户目标的程度。
	
	可用性：学习和使用软件的难易程度，包括操作软件，为软件准备输入数据、解释软件输出结果等。
	
	可靠性：完软件完成预期功能，成功运行的概率。
	
	有效性：软件系统利用计算机的时间资源和空间资源完成系统功能的能力。
	
	可维护性：软件制品交付用户使用后，能够对他进行修改，以便改正潜伏的缺陷、改进性能和其他属性，是软件制品适应环境的变化。
	
	可移植性：将软件安装在不同计算机系统或环境的难易程度。
	
	安全性：控制或保护程序的数据不受破坏的机制，以防止程序和数据受到意外或蓄意的存取、修改、使用、毁坏和泄密。
	
	可复用性：概念或功能相对独立的一个或一组相关模块定义为一个软构建，软构建可以在多种场合应用的场合称为构建的可复用性。

###	IEE93给出的软件工程定义
	
	将系统的、规范的、可量化的方法应用于软件的开发、运行和维护的过程。
	
	及上述方法的研究
	
###	软件工程五要素
	
	项目，人，过程，软件制品，方法和工具。
	
##软件危机

###	什么是软件危机

	软件在开发和维护过程中遇到的一系列问题

	1.困扰学术界和工业界

	2.用户对软件开发缺乏信心

	3.软件开发的高投入和高风险

###	软件危机的表现

	成本高

IBM 360 OS, 5000多人年，耗时4年(1963－1966)，花费2亿多美元

	软件质量得不到保证

	软件应用面的扩大：科学计算、军事、航空航天、工业控制、企业管理、办公、家庭；软件越来越多的应用于高安全性的系统，对软件质量提出更高的要求


	进度难以控制
	
项目延期比比皆是，由于进度问题而取消的软件项目较常见，只有一小部分的项目能够按期完成


	维护非常困难
	
软件维护的多样性，软件维护的复杂性，软件维护的副作用。

###	产生危机的根源

逻辑产品，不同于物理产品，复杂性高，逻辑复杂性，远高于硬件复杂性

软件的复杂性随规模呈指数级上升

规模大，应用扩大，代码量，1000万行，仍在不断膨胀

影响软件生产率和质量的因素比较复杂，人员的能力和水平，团队合作

缺乏有效、系统原理、原则、方法和工具的指导和辅助


###	解决软件工程的途径

提出有效的方法和工具支持软件开发，1968年提出软件工程概念和思想，20世纪70年代的结构化软件开发方法，20世纪80年代的面向对象的软件开发方法，新的技术: 软件重用、快速原型、需求工程，典型技术: COM, Java, C++, J2EE, .Net, ….，支撑工具和环境：Jbuilder, Visual Studio, WebLogic, …

###	解决软件工程的管理途径

20世纪80年代末，美国DoD和工业界开始认识到管理的重要性,美国DoD的一项研究表明，70%的项目由于管理不善导致难以控制进度、成本和质量；进一步的研究发现：管理是影响软件项目成功开发的全局性因素，而技术只影响局部。如果软件开发组织不能对软件项目进行有效管理，就不能充分发挥软件开发方法和工具的潜力，也就不能高效率地开发出高质量的软件产品

##	软件工程的目标和原则

###	软件工程目标

追求高质量高效率
       在给定成本、进度的前提下，开发出具有可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性并满足用户需要的软件产品

###	软件工程原则

	抽象：采用分层抽象的方法可以使我们的思维聚焦于问题本质，从而简化问题，控制问题复杂度，支持复杂、庞大软件系统的开发 。
	
	模块化：模块是程序中一个逻辑上相对独立、具有良好的接口定义的编程单位：过程、函数、类、程序包等，模块化是将复杂的系统分解为一个个相对独立的模块来加以实现，有助于抽象和信息隐藏以及表示复杂的系统 
	
	信息隐藏：将模块中的软件设计决策信息封装起来的技术，只知道它的功能以及对外的接口，而不知它的内部细节，有助于软件开发人员的注意力集中于更高的抽象层次  
	
	局部化：确保模块内各成分关系密切而模块之间的关系松散，保证模块具有良好的独立性 

	一致性：整个软件系统均使用统一的符号、概念和术语

	完整性：整个软件系统不丢失任何重要的成分，软件完全实现系统所需功能的程度

	可验证性：软件系统应易于检查、测试和评审
	
## 软件过程模型

##	瀑布模型

	瀑布模型按照各阶段的目标和任务逐步进行开发，直至通过确认测试，向用户交付最终软件制品为止
![瀑布模型](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=259a6fc4e6cd7b89fd6132d16e4d29c2/6a600c338744ebf8ebd10b31d9f9d72a6059a718.jpg "瀑布模型")

##	带反馈的瀑布模型
	实践中，对某一阶段软件制品的评审会经常发现缺陷和疏漏，这时不得不暂停这一阶段的活动，反馈到前面的有关阶段修正缺陷、增补疏漏，然后再重复前面的工作，直至该阶段通过评审后再进入下一阶段。于是，瀑布模型演变成带有反馈的瀑布模型.
![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=763e8c0da8d3fd1f2204aa6851274e7a/e824b899a9014c089ab337860a7b02087bf4f40d.jpg)

###	瀑布模型的特点
	瀑布模型思路简洁、明确，上一阶段的开发结果是下一阶段开发的输入，相邻两个阶段具有因果关系，紧密相联。
为了保障软件开发的正确性，每一阶段任务完成后，都必须对它的阶段性制品（文档、原型、程序等）进行评审，确认之后再转入下一阶段。
瀑布模型的可行性研究、需求、设计、编码、测试分离，有利于软件的体系结构设计，规范了软件开发活动，有利于开发人员的组织、管理。
对于规模较小、软件需求比较稳定的项目或子系统，采用瀑布模型能够显著提高软件开发的质量和效率。

###	瀑布模型的缺点
	①必须要求客户和系统分析员确定软件需求后才能进行后续的软件开发工作，但多数场合给出大型软件项目的全部需求是困难的，有时甚至是不现实的；

	②需求确定后，用户和软件项目负责人要等相当长的时间(经过设计、实现、测试、运行)才能得到软件的最初版本，如果用户对这个软件提出比较大的修改意见，那么整个软件项目将会蒙受巨大的人力、财力和时间损失；

	③开发人员在瀑布模型“上游”出现“过失” (mistake)会为软件制品带来“缺陷”(fault)并潜伏在软件制品中，缺陷会误导“下游”的开发活动，若未被发现，则软件运行时会造成系统“故障” (failure)。
	
###	使用瀑布模型的注意事项
	①需求明确后再施工；

	②每个阶段的结果要及时评审和测试，发现的问题妥善处理后再开始下一阶段的工作；

	③开发周期尽量短，尽快给用户使用，得到反馈意见；

	④一次开发的软件规模不宜过大。


##	增量模型

###	产因
	对于软件开发前需求基本确定的大型软件项目，采用瀑布模型开发时间长、不能快速占领市场、不能在短期内得到用户的反馈意见。

###	基本思想
	开发人员与用户协商将需求分解，划分为一系列增量，并为增量排序，急需的增量排在前面先开发，不急需的放在后面。每个增量都历经需求、设计、编码、测试、移交几个阶段。根据增量间的依赖关系、开发人员和项目的实际情况，有些增量可串行开发，有些可并行开发。在此过程中不断开发、不断集成、不断交付，直到完成所有增量的开发，得到最终的软件制品。

![](http://wiki.mbalib.com/w/images/d/d0/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.jpg)

###	增量模型的优点
	①在软件开发过程中，按照增量持续不断的发布软件新版本，可及时获得客户的反馈，用于调整后续的软件开发策略；
	
	②由于软件需求是确定的，可先对软件体系结构进行设计，增量开发过程能保持良好的软件体系结构。

###	增量模型的缺点
	①增量规模不能大（开发不要超过20k行代码），否则会暴露瀑布模型的缺点；
  
	②将客户需求分解成增量序列必须对系统需求十分了解，并有顶层设计的经验；
  
	③多数系统都需要基本服务，如何为基本服务定义增量，何时实现这些增量，处理起来比较困难。

##	原型建造模型

###	基本概念
	原型(prototyping)：是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。 
	原型向客户展示了待开发软件系统的全部或部分功能和性能，在征求客户对原型意见的过程中，进一步修改、完善、确认软件系统的需求并达到一致的理解。
###	快速开发原型的途径
	①利用计算机模拟软件系统的人机界面和人机交互方式；
	
	②利用敏捷软件开发方法开发一个工作原型，实现软件系统重要的，容易产生误解的部分功能；

	③找来若干个类似软件，利用这些软件向客户展示软件需求中的部分或全部功能。

###原型建造的种类
	原型有两类。

	(1)抛弃型原型(实验性原型)
  利用原型定义和确认了软件需求后，原型就完成了任务。
  开发人员就可以按照确认的需求进行软件设计、编码、测试。

  (2)应用型原型(进化性原型)
  利用原型确认软件需求后，对原型进一步加工、完善，使之成为系统的一部分
![](http://wiki.mbalib.com/w/images/thumb/2/28/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.jpg/495px-%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.jpg)






